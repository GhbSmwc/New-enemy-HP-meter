<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: rgb(221, 221, 221);
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			div.CodeBlock {
				overflow: auto;
				width: 1000px;
				height: 500px;
				border: 1px solid white;
				resize: both;
				background-color: #101010;
			}
			pre {
				margin: 0px;
			}
			*.FixedWidth {
				font-family: monospace;
			}
			
			*.NoLineBreak {
				font-family: monospace;
				white-space: pre;
			}
			*.Center {
				text-align: center;
			}
			
			li {
				padding: 5px;
			}
			tr.RedBackground {
				background-color: #400000;
			}
		</style>
	</head>
<body style="max-width: 1000px; margin: auto; padding: 15px">
<h1 class="Center">Enemy HP patch</h1>
<div class="Center">By HammerBrother</div>
<div>
	<p>This ASM resource displays the enemies' HP as a numerical value and/or as a bar when they take damage on the status bar/HUD.</p>
	<p>This is similar to <i>Kirby & The Amazing Mirror</i>. With the differences being:</p>
	<ul>
		<li>The bar in this resource displays its current HP percentage and its previous HP via a rapid-flicker. In K&tAM, the bar
		updates with a gradual decrease without showing the previous HP percentage.</li>
		
		<li>Touching enemies will not display the meter, in K&tAM, it is possible to make it show its HP without damaging the enemy
		by having Sone Kirby in his stone form (not moving or rolling down slopes) and an enemy passes through you.</li>
	</ul>
	<p>So few enemies in SMW can take damage without being one-shotted, they are Chucks, Wendy/Lemmy, Ludwig, Morton/Roy, Big Boo boss,
	and Bowser (although the status bar in that battle is disabled).</p>
</div>
<div>
	<p>Note that code blocks here can be easily copied by holding down CTRL and double-clicking the text.</p>
</div>
<hr>
<div>
	<h2>Table of contents</h2>
	<ul>
		<li><a href="#JMPTo_HowtoInsert" id="ToC_HowtoInsert">How to insert</a></li>
		<li><a href="#JMPTo_RAMUsage" id="ToC_RAMUsage">RAM usage documentation</a></li>
		<li><a href="#JMPTo_MakeSpritesDisplayHP" id="ToC_MakeSpritesDisplayHP">Making sprites display their HP</a></li>
		<ul>
			<li><a href="#JMPTo_MakeSpritesDisplayHP_BossIntroFill" id="ToC_MakeSpritesDisplayHP_BossIntroFill">(Optional) Boss intro-fill</a></li>
			<li><a href="#JMPTo_MakeSpritesDisplayHP_GetHPValue" id="ToC_MakeSpritesDisplayHP_GetHPValue">Obtaining HP value...</a></li>
			<ul>
				<li><a href="#JMPTo_MakeSpritesDisplayHP_GetHPValue_ConvertDamageToHP" id="ToC_MakeSpritesDisplayHP_GetHPValue_ConvertDamageToHP">...from a damage counter</a></li>
				<li><a href="#JMPTo_MakeSpritesDisplayHP_GetHPValue_GetStraightFromHPSprTbl" id="ToC_MakeSpritesDisplayHP_GetHPValue_GetStraightFromHPSprTbl">...from its own sprite table as HP</a></li>
			</ul>
			<li><a href="#JMPTo_MakeSpritesDisplayHP_TakingDamage" id="ToC_MakeSpritesDisplayHP_TakingDamage">Damage handler</a></li>
		</ul>
		<li><a href="#JMPTo_Notes" id="ToC_Notes">Notes</a></li>
		<li><a href="#JMPTo_Troubleshooting" id="ToC_Troubleshooting">Troubleshooting</a></li>
	</ul>
</div>
<div>
	<h2>What you need</h2>
	<ul>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=17109">Lunar magic</a></li>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=14560">Asar</a></li>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=39036">Uberasm tool version 2.0 or higher</a> (latest version recommended)</li>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=40579">Shared Subroutines</a> (version 4.2.1 or later). Needed because there are subroutines that may be needed for pixi sprites, SMW sprites, and uberasm tool code, and
		their subroutines are isolated from one another.</li>
	</ul>
	<h2>Recommended</h2>
	<ul>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=37432">Pixi</a></li>
		<li>
			Status bar/HUD enhancement patches, this ASM package by default assumes you are using the <a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar patch</a>.
			Vanilla status bar is way-too limited.
		</li>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=39887">Address Tracker</a>, if you have trouble knowing if there are RAM conflicts (two unrelated resources uses the same addresses at the same time).</li>
	</ul>
	<h2>Documentations of other ASM resources</h2>
	<ul>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=38296">Status bar tutorial (mainly on the string and number system used here)</a></li>
		<li><a href="https://www.smwcentral.net/?p=section&a=details&id=38297">Graphical Bar</a></li>
	</ul>
</div>
<hr>
<div>
	<h2><a href="#ToC_HowtoInsert" id="JMPTo_HowtoInsert">^</a>How to insert</h2>
	<ol>
		<li>ASM stuff</li>
		<ol>
			<li>Make any changes necessary on the defines, especially freeram data. It is likely that you would have them take up a large amount of bytes due to
			them being sprite tables. There are multiple files due to some resources are general-purpose, such as the graphical bar can be used for player's HP
			or other meters besides HP. The defines specific to sprite HP are in <kbd>EnemyHPMeterDefines.asm</kbd>. For editing what tiles used by general-purpose
			subroutines, they're in <kbd>NumberDisplayRoutinesDefines.asm</kbd>.<br><br>
			
			Once you are done, you'll need to have copies of these ASM text files (not the folders itself containing them) in same directory as the tools'
			<kbd>.exe</kbd> programs are at (pixi and uberasm tool). This also applies to Shared Subroutines' <kbd>SubroutineDefs.asm</kbd> since UAT and pixi need a define of a subroutine. Do not have them in any
			subfolders beyond that area. Make sure you do not move the define files	as the patch will include those define files (better to copy than to cut/move them).<br><br>
			
			If you later make changes in any of the defines and reinsert by one tool, make sure you update all others and reinsert by other tools.<br><br>
			
			The freeram defines are in <kbd>EnemyHPMeterDefines.asm</kbd> for the main part of the resource, in <kbd>GraphicalBarDefines.asm</kbd> for handling
			graphical bar codes, and <kbd>NumberDisplayRoutinesDefines.asm</kbd> for handling left/right aligned number display (suppresses leading zeros). Other defines
			aren't technically freeram (<kbd>StatusBarDefines.asm</kbd> is meant to re-use the same RAM as the status bar enhancement patch for tile data, and <kbd>SA1StuffDefines.asm</kbd>
			is used so that the other define files can recognize which alternate RAM to use depending on LoROM or SA-1).
			
			</li>
			<li>
				With Shared Subroutines, do the following:
				<ol>
					<li>First thing first, make a restore point or a backup of your game file before applying shared subroutines in case of a crash if you set the freespace incorrectly.</li>
					<li>Have the enemy HP meter's defines inside Shared Subroutines' folder <kbd>SharedSub_Defines</kbd>.</li>
					<li>In the folder <kbd>SharedSubroutines</kbd> of this package, copy the entire code and paste it in Shared Subroutines' <kbd>subroutinecode.asm</kbd>. It can be anywhere, but not in the middle of a subroutine code.</li>
					<li>
						Any subroutines you don't use (for your entire hack, no ASM from anywhere in your ROM using it, not just the enemy HP system), feel free to omit them (remove the subroutine code, the JML and define list item) to save ROM space. Just to let you know that you can use some of these subroutines for other than sprite HP, as many of them are general-purpose.
						Subroutines that you likely not need are:
						<ul>
							<li>
								Graphical bar routines. Not used by the sprite HP system if <kbd>!Setting_SpriteHP_DisplayGraphicalBar == 0</kbd>
								<ul>
									<li><kbd>CalculateGraphicalBarPercentage</kbd></li>
									<li><kbd>CalculateGraphicalBarPercentageRoundDown</kbd></li>
									<li><kbd>CalculateGraphicalBarPercentageRoundUp</kbd></li>
									<li><kbd>ConvertBarFillAmountToTiles</kbd></li>
									<li><kbd>DrawGraphicalBarSubtractionLoopEdition</kbd></li>
									<li><kbd>GraphicalBarRoundAwayEmpty</kbd></li>
									<li><kbd>GraphicalBarRoundAwayEmptyFull</kbd></li>
									<li><kbd>GraphicalBarRoundAwayFull</kbd></li>
									<li><kbd>WriteBarToHUD</kbd></li>
									<li><kbd>WriteBarToHUDFormat2</kbd></li>
									<li><kbd>WriteBarToHUDLeftwards</kbd></li>
									<li><kbd>WriteBarToHUDLeftwardsFormat2</kbd></li>
								</ul>
							</li>
							<li>
								Bar animation routines, not used by the sprite HP system if <kbd class="NoLineBreak">!Setting_SpriteHP_DisplayGraphicalBar == 0</kbd> OR <kbd class="NoLineBreak">!Setting_SpriteHP_BarAnimation == 0</kbd>
								<ul>
									<li><kbd>SpriteHPRemoveRecordEffect</kbd></li>
								</ul>
							</li>
							<li>
								Number display routines, not used if <kbd class="NoLineBreak">!Setting_SpriteHP_DisplayNumerical == 0</kbd>. Note that any subroutine with 2 versions with and without <kbd>Format2</kbd> will and will not be used
								depending on <kbd>!StatusbarFormat</kbd> in <kbd>StatusBarDefines.asm</kbd>. When <kbd>!StatusbarFormat</kbd> is set to <kbd>$01</kbd>, then only versions without the <kbd>Format2</kbd> will be used, otherwise (<kbd>$02</kbd>)
								means only <kbd>Format2</kbd> will be used.<br><br>
								
								The reason for the dual-formats is because there are 2 types of status bar tile data formatting: 2 tables; <kbd>%TTTTTTTT, %TTTTTTTT, ...</kbd> and <kbd>%YXPCCCTT, %YXPCCCTT, ...</kbd> for the non-<kbd>Format2</kbd>
								(which are most of Ladida's status bar patches, <a href="https://www.smwcentral.net/?p=section&a=details&id=35718">Minimalist</a>, and <a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3</a>), and the
								<kbd>Format2</kbd> version have one table interleaved: <kbd>%TTTTTTTT, %YXPCCCTT, (repeats the two)</kbd> (which are Kaijyuu's <a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar</a> and MarioFanGamer's
								<a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld Border Plus</a> (OWB+) patch). It's possible you'll want to have both formats if you have OWB+ for "Overworld HUD" and using non-<kbd>Format2</kbd> status bars for levels.
								<ul>
									<li><kbd>ConvertToRightAligned</kbd> (only used if <kbd class="NoLineBreak">!Setting_SpriteHP_NumericalTextAlignment == 2</kbd>)</li>
									<li><kbd>ConvertToRightAlignedFormat2</kbd> (same as above)</li>
									<li><kbd>RemoveLeadingZeroes16Bit</kbd> (only used if <kbd class="NoLineBreak">!Setting_SpriteHP_NumericalTextAlignment == 0</kbd> or when you have <kbd class="NoLineBreak">!Setting_SpriteHP_DisplayNumerical == 1</kbd> and <kbd class="NoLineBreak">!Setting_SpriteHP_NumericalTextAlignment == 2</kbd>, which is a right-aligned single number)</li>
									<li><kbd>SixteenBitHexDecDivision</kbd></li>
									<li><kbd>SuppressLeadingZeros</kbd> (used if <kbd>!Setting_SpriteHP_NumericalTextAlignment</kbd> is set to <kbd>1</kbd> or <kbd>2</kbd>), left or right aligned</li>
									<li><kbd>WriteStringDigitsToHUD</kbd></li>
									<li><kbd>WriteStringDigitsToHUDFormat2</kbd></li>
								</ul>
							</li>
							<li>
								Other:
								<ul>
									<li><kbd>SpriteHPIntroEffect</kbd> (delete this if you don't want to have a boss intro-fill effect)</li>
								</ul>
							</li>
						</ul>
						
					</li>
					<li>
						In Shared Subroutine's <kbd>sharedsub.asm</kbd> in the JML list, paste the following (remove JML list items you won't be using for your entire hack):
<div class="CodeBlock" style="height: 340px;"><pre>autoclean JML CalculateGraphicalBarPercentage
autoclean JML CalculateGraphicalBarPercentageRoundDown
autoclean JML CalculateGraphicalBarPercentageRoundUp
autoclean JML ConvertBarFillAmountToTiles
autoclean JML ConvertToRightAligned
autoclean JML ConvertToRightAlignedFormat2
autoclean JML DrawGraphicalBarSubtractionLoopEdition
autoclean JML MathDiv32_16
autoclean JML MathDiv
autoclean JML MathMul16_16
autoclean JML RemoveLeadingZeroes16Bit
autoclean JML GraphicalBarRoundAwayEmpty
autoclean JML GraphicalBarRoundAwayEmptyFull
autoclean JML GraphicalBarRoundAwayFull
autoclean JML SixteenBitHexDecDivision
autoclean JML SuppressLeadingZeros
autoclean JML WriteBarToHUD
autoclean JML WriteBarToHUDFormat2
autoclean JML WriteBarToHUDLeftwards
autoclean JML WriteBarToHUDLeftwardsFormat2
autoclean JML WriteStringDigitsToHUD
autoclean JML WriteStringDigitsToHUDFormat2
autoclean JML SpriteHPDamage
autoclean JML SpriteHPRemoveRecordEffect
autoclean JML SpriteHPGetSlotIndex
autoclean JML SpriteHPIntroEffect</pre>
</div>
					</li>
					<li>
						Open Shared Subroutines' <kbd>SharedSub_Defines/SubroutineDefs.asm</kbd> and paste the following (same as above, remove define list items you don't use):
<div class="CodeBlock" style="height: 340px;"><pre>		%SetSharedSubDefine(SharedSub_CalculateGraphicalBarPercentage)
		%SetSharedSubDefine(SharedSub_CalculateGraphicalBarPercentageRoundDown)
		%SetSharedSubDefine(SharedSub_CalculateGraphicalBarPercentageRoundUp)
		%SetSharedSubDefine(SharedSub_ConvertBarFillAmountToTiles)
		%SetSharedSubDefine(SharedSub_ConvertToRightAligned)
		%SetSharedSubDefine(SharedSub_ConvertToRightAlignedFormat2)
		%SetSharedSubDefine(SharedSub_DrawGraphicalBarSubtractionLoopEdition)
		%SetSharedSubDefine(SharedSub_MathDiv32_16)
		%SetSharedSubDefine(SharedSub_MathDiv)
		%SetSharedSubDefine(SharedSub_MathMul16_16)
		%SetSharedSubDefine(SharedSub_RemoveLeadingZeroes16Bit)
		%SetSharedSubDefine(SharedSub_GraphicalBarRoundAwayEmpty)
		%SetSharedSubDefine(SharedSub_GraphicalBarRoundAwayEmptyFull)
		%SetSharedSubDefine(SharedSub_GraphicalBarRoundAwayFull)
		%SetSharedSubDefine(SharedSub_SixteenBitHexDecDivision)
		%SetSharedSubDefine(SharedSub_SuppressLeadingZeros)
		%SetSharedSubDefine(SharedSub_WriteBarToHUD)
		%SetSharedSubDefine(SharedSub_WriteBarToHUDFormat2)
		%SetSharedSubDefine(SharedSub_WriteBarToHUDLeftwards)
		%SetSharedSubDefine(SharedSub_WriteBarToHUDLeftwardsFormat2)
		%SetSharedSubDefine(SharedSub_WriteStringDigitsToHUD)
		%SetSharedSubDefine(SharedSub_WriteStringDigitsToHUDFormat2)
		%SetSharedSubDefine(SharedSub_SpriteHPDamage)
		%SetSharedSubDefine(SharedSub_SpriteHPRemoveRecordEffect)
		%SetSharedSubDefine(SharedSub_SpriteHPGetSlotIndex)
		%SetSharedSubDefine(SharedSub_SpriteHPIntroEffect)</pre>
</div>
					Now make sure their order and positions in the list of the entire JML and define list matches (if you paste the JML list starting at the 51st item, then the define list must also be placed starting at the 51st item),
					else define names gets assigned to the wrong subroutine label, which causes glitches or crashes.</li>
					<li>
						Now in the define file of the previous set, you must set <kbd>!Freespace_SharedSub_JMLList</kbd> to be at an address that is the start of a freespace. Follow the instructions in Shared Subroutine's Readme on how to
						locate freespace.
					</li>
					<li>Now patch <kbd>sharedsub.asm</kbd> to your game.</li>
				</ol>
			</li>
			
			<li>Patch a status bar/HUD enhancement patch into your game. Note that this ASM resource by default, assumes you are using the Super Status Bar patch. If this is not the case, you need to open <kbd>StatusBarDefines.asm</kbd>
			of this package and change the base address to match with whatever status bar patch you're using that are the tile data, then reinsert UAT and pixi if you have inserted prior.</li>
			
			<li>Patch <kbd>HPSystemForSMWSprites.asm</kbd> to your game. This adds a proper health system for some sprites and bosses and fixes <a href="#HitCountJank">an anomaly for SMW</a>.
			This alone does not display meter, but will write to various RAM for the uberasm tool code to display it.</li>
			
			<li>Insert the ASM files to Uberasm tool. The provided folders should be obvious.</li>
			
			<li>Same with pixi, if you want custom sprites. I provided a test sprite in the folder for demonstration.</li>
		</ol>
		<li>Lunar Magic stuff</li>
		<ol>
			<li>In all levels accessible by the player, insert the layer 3 status bar ExGFX by &ldquo;Quick Extract ExGFX from ROM&rdquo; (blue mushroom icon) to spawn a <kbd>ExGraphics</kbd> folder (unless you did so already), then,
			inside this ASM resource, navigate to <kbd>LM stuff/ExGraphics</kbd>. Here you'll find a graphic file (uses ExGFX slot $80 by default, rename to have it at a different slot number). This file should
			be pasted in the ExGraphics of your game file. To insert into your game, &ldquo;Quick Insert ExGFX to ROM&rdquo; (golden mushroom). Finally, &ldquo;Open "Layer 3 GFX/Tilemap Bypass" Dialog&rdquo; (green
			poison mushroom), and set LG1 to use your inserted graphics file (by default, should be $80 if you didn't change the slot number)<br><br>
			
			This graphic is for layer 3 status bar, since some symbols needed for the display are missing. The tiles used are the slash (&ldquo;/&rdquo;, if you have <kbd>!Setting_SpriteHP_DisplayNumerical</kbd> set to <kbd>2</kbd>) and graphical bar tiles (if you have
			<kbd>!Setting_SpriteHP_DisplayGraphicalBar</kbd> set to <kbd>1</kbd>).
			
			</li>
		</ol>
		<li>And now you are done.</li>
	</ol>
</div>
<hr>
<div>
	<h2><a href="#ToC_RAMUsage" id="JMPTo_RAMUsage">^</a>RAM usage documentation</h2>
		<p>
			Notes:
			<ul>
				<li>Define <kbd>!sprite_slots</kbd> is the number of sprite slots that exists. For LoROM, its 12, if SA-1, its 22. Note that at the time of writing this, Pixi have <kbd>!SprSize</kbd> and not <kbd>!sprite_Slots</kbd>.</li>
			</ul>
		</p>
		<p>
			Other than the RAM data for graphical bar and HexDec routines (defines are in <kbd>GraphicalBarDefines.asm</kbd> and <kbd>NumberDisplayRoutinesDefines.asm</kbd>), the sprite HP data and display handler are in <kbd>EnemyHPMeterDefines.asm</kbd>,
			defined as <kbd>!Freeram_SpriteHP_SpriteHPData</kbd>. It's layout are (in this order, starting at an address defined as <kbd>!Freeram_SpriteHP_SpriteHPData</kbd>, and advancing to higher-addresses, placed contiguously):
			<table>
				<tr>
					<th>Define</th>
					<th><abbr title="&ldquo;State&rdquo; refers to an individual value representing the state of something, &ldquo;Sprite slots&rdquo; are tables that each byte correspond to a sprite slot, which is how multiple entities can exists.">Type</abbr></th>
					<th>Number of bytes</th>
					<th>Description</th>
					<th>Use condition</th>
				</tr>
				<tr>
					<th><kbd>!Freeram_SpriteHP_MeterState</kbd></th>
					<td class="Center">State</td>
					<td class="NoLineBreak Center">1</td>
					<td>
						HP meter state, the values are:
						<ul>
							<li>From <kbd>$00</kbd> to <kbd>!sprite_slots-1</kbd> will make the bar visible and display HP of the sprite of the slot corresponding to this value.</li>
							<li>
								From <kbd>!sprite_slots</kbd> to <kbd>(!sprite_slots*2)-1</kbd> is the same as above (subtract by <kbd>!sprite_slots</kbd> to obtain the sprite slot number) but for the <kbd>intro-fill</kbd> animation (bar appears empty, and fills up, useful for boss fight). This only applies
								if <kbd>!Setting_SpriteHP_DisplayGraphicalBar</kbd> and <kbd>!Setting_SpriteHP_BarAnimation</kbd> set to <kbd>1</kbd>.
							</li>
							<li><kbd>$FF</kbd> Means don't display the meter, which occurs when the enemy despawns or dies the meter is displaying for. Note that this will write blank tiles every frame.</li>
							<li><kbd>$FE</kbd> is &ldquo;disabled&rdquo;, will only write blank tiles to clear the HP meter display once, then set itself to <kbd>$FD</kbd>. Make sure you do not set this to <kbd>$FE</kbd> every frame though.</li>
							<li><kbd>$FD</kbd> is also &ldquo;disabled&rdquo;, but will not write anything on the spot the meter occupies (stops writing tiles here every frame, including blank tiles).</li>
						</ul>
						Note that when disabled, you can use that spot where the meter occupies without it being overwritten. It also prevents displaying the meter if the intro-fill animation plays, as well as displaying the meter when damaging enemies.
					</td>
					<td>Always</td>
				</tr>
				<tr>
					<th><kbd>!Freeram_SpriteHP_CurrentHPLow</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>Sprite's current HP, low byte.</td>
					<td>Always</td>
				</tr>
				<tr>
					<th><kbd>!Freeram_SpriteHP_MaxHPLow</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>Sprite's maximum HP, low byte.</td>
					<td>Always</td>
				</tr>
				<tr class="RedBackground">
					<th><kbd>!Freeram_SpriteHP_CurrentHPHi</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>Sprite's current HP, high byte.</td>
					<td>if <kbd>!Setting_SpriteHP_TwoByte</kbd> is set to <kbd>1</kbd></td>
				</tr>
				<tr class="RedBackground">
					<th><kbd>!Freeram_SpriteHP_MaxHPHi</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>Sprite's maximum HP, high byte.</td>
					<td>if <kbd>!Setting_SpriteHP_TwoByte</kbd> is set to <kbd>1</kbd></td>
				</tr>
				<tr class="RedBackground">
					<th><kbd>!Freeram_SpriteHP_BarAnimationFill</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>The secondary fill amount used for the animation of the bar fill going up and down. This does so by using a rapid-flicker to show the difference between current HP fill and previous HP fill. If intro-fill mode is
					active, will only show the filling up animation.</td>
					<td>if <kbd>!Setting_SpriteHP_DisplayGraphicalBar</kbd> and <kbd>!Setting_SpriteHP_BarAnimation</kbd> is set to <kbd>1</kbd></td>
				</tr>
				<tr class="RedBackground">
					<th><kbd>!Freeram_SpriteHP_BarAnimationTimer</kbd></th>
					<td class="Center">Sprite slots</td>
					<td class="NoLineBreak Center">!sprite_slots</td>
					<td>Delay timer that decreases itself once per frame. When nonzero, <kbd>!Freeram_SpriteHP_BarAnimationFill</kbd> briefly freezes
					before incrementing or decrementing to its current HP fill amount.</td>
					<td>if <kbd>!Setting_SpriteHP_DisplayGraphicalBar</kbd>, <kbd>!Setting_SpriteHP_BarAnimation</kbd>, and <kbd>!Setting_SpriteHP_BarChangeDelay</kbd> is set to nonzero values.</td>
				</tr>
			</table><br>
			Anything with a red background indicates those are optional features you can disable and will not be used. The total number of bytes ranging are:
			<ul>
				<li>25 to 73 bytes on LoROM.</li>
				<li>45 to 133 bytes on SA-1.</li>
			</ul>
			If you want to know exactly where they are located, open <kbd>EnemyHPMeterDefines.asm</kbd> and set <kbd>!Setting_SpriteHP_DisplaySpriteHPDataOnConsole</kbd> to <kbd>1</kbd> and reinsert (works on any tool except pixi since <kbd>print</kbd>
			command behaves differently). On the asar console window, will display the address of each subsection of the sprite HP data (this is in <a href="https://www.smwcentral.net/?p=section&a=details&id=39887">address tracker format</a> along with other summaries.).
		</p>
	<hr>
	<h2><a href="#ToC_MakeSpritesDisplayHP" id="JMPTo_MakeSpritesDisplayHP">^</a>Making sprites display their HP</h2>
	<p>Note that this section assumes you know how to program in 65c816 assembly language as well as instructions for Asar on how it compiles code. <a href="https://www.smwcentral.net/?p=section&a=details&id=14268">See this tutorial</a> on how to get started and asar's
	document on codes for the tool (<kbd>docs/manuel/index.html</kbd>).</p>
	
	<p>This section covers on how to <b>display</b> the sprite's HP.</p>
	
	<p>To program a health system for existing custom sprites, they should store a value representing how much damage (can be any value it increases), hits (counts up by one regardless of an attack), or
	remaining health (starts at any nonzero value and decreases each damage) else the sprite will never die or dies in one hit. Because each sprite is different, documenting every one of them would make
	this tutorial very long. So I'll explain the principals and with some examples.</p>
	
	<p>I provided an example test sprite under <kbd>pixi/sprites/simple_sprite.asm</kbd> for testing the HP system.</p>
	
	<p>Because HP-related defines are heavily involved here, it's important to include the define files at the top of your sprite's ASM file, like this:
<div class="CodeBlock" style="height: 50px;"><pre>	incsrc "../SubroutineDefs.asm"
	incsrc "../EnemyHPMeterDefines.asm"
	incsrc "../GraphicalBarDefines.asm"</pre></div><br>
	Else you get define not being defined errors. Then after the include-defines, have the macros (the ones on this HTML file) being set/defined (anything with a <span class="NoLineBreak">macro MacroName(Pram1, Pram2...) ... endmacro</span>).</p>
	
	<p>The following stuff is transferring its health and damage RAM to this resource's HP RAM so that it gets displayed. Yes you can modify the custom sprite not to use its own vanilla sprite table RAM
	at all and instead directly use this ASM resources' current and max HP RAM (in a way similar to the provided example sprite), however that comes with caveats and may need further edits:
	<ul>
		<li>
			If the sprite utilizes a damage counter (starts at 0 and hits increases this value), you need to reverse it. If there are damage amount thresholds to trigger different phases, that also needs to be
			reversed (for example, 10 points of damage to defeat an enemy, and 7 or more points trigger phase 2. That needs to be changed to a 10 HP sprite, and triggers phase 2 with its HP drops to 3 or lower).
		</li>
		<li>
			Most sprites with a health system don't have 16-bit health. If you have <kbd>!Setting_SpriteHP_TwoByte == 1</kbd>, you need to either always set their <kbd>!Freeram_SpriteHP_MaxHPHi</kbd> to always zero,
			or every code that reads and set their HP to account the high byte when their HP value can go greater than 255.
		</li>
	</ul>
	
	</p>
	
	<h3><a href="#ToC_MakeSpritesDisplayHP_BossIntroFill" id="JMPTo_MakeSpritesDisplayHP_BossIntroFill">^</a>(Optional) Boss intro-fill</h3>
	<p>For boss sprites, to have an optional &ldquo;intro-fill&rdquo; effect (meter automatically appears empty and fills up at the start of a fight), run this code under a sprite init, or under main (if you want the
	animation after a cutscene after the sprite spawns, but make sure it does not execute every frame) by calling it like this: <kbd>JSL !SharedSub_SpriteHPIntroEffect</kbd>. Note that you must have <kbd>!Setting_SpriteHP_DisplayGraphicalBar</kbd> and
	<kbd>!Setting_SpriteHP_BarAnimation</kbd> be set to 1 (else it just appears full without animation):
<div class="CodeBlock" style="height: 110px;"><pre>
	;Have the following as an option on your custom sprite if you are willing to submit it to SMWC.
		!IntroFill = 1                                                      ;&gt;0 = no, 1 = yes (switch display to boss sprite with filling animation or simply a full bar if animation disabled).
	
	if !IntroFill
		JSL !SharedSub_SpriteHPIntroEffect
	endif
</pre></div>
	</p>
	<h3><a href="#ToC_MakeSpritesDisplayHP_GetHPValue" id="JMPTo_MakeSpritesDisplayHP_GetHPValue">^</a>Obtaining HP value...</h3>
	<p>This covers on how to extract data from a sprite table that is being used to track the amount of damage or health, then storing that data to <kbd>!Freeram_SpriteHP_CurrentHPLow</kbd>, <kbd>!Freeram_SpriteHP_MaxHPLow</kbd>
	(<kbd>!Freeram_SpriteHP_CurrentHPHi</kbd> and <kbd>!Freeram_SpriteHP_MaxHPHi</kbd> in addition if <kbd>!Setting_SpriteHP_TwoByte == 1</kbd>) so that it gets displayed on the HUD. This must run every frame (as a failsafe in
	case if the sprite's real health sprite table changes without that being shown) on the sprite main (preferably at the start). Note that the following code uses a macro that doesn't get used unless you call it.</p>
	<h4><a href="#ToC_MakeSpritesDisplayHP_GetHPValue_ConvertDamageToHP" id="JMPTo_MakeSpritesDisplayHP_GetHPValue_ConvertDamageToHP">^</a>...from a damage counter</h4>
	<p>When a custom sprite stores a number (<kbd>DamageCount</kbd>) that starts at 0, and increases (commonly by 1 as a hit counter) for each hit the sprite receives, HP can be found by
	taking the amount of damage needed to defeat the enemy, and subtract that by <kbd>DamageCount</kbd> to obtain the remaining damage needed to defeat the sprite:
<div class="CodeBlock" style="height: 250px;"><pre>
	macro ConvertDamageAmountToHP(DamageCountSpriteTableRAM, DamageAmountToDie)
		?HitCountToHP:
			LDA.b #&lt;DamageAmountToDie&gt;                                      ;&gt;The amount of damage that would kill the sprite
			STA !Freeram_SpriteHP_MaxHPLow,x                                ;&gt;This also means its maximum health is this value.
			SEC                                                             ;\RemainingHP = DamageAmountToDie - DamageCount
			SBC &lt;DamageCountSpriteTableRAM&gt;,x                               ;/
			BCS ?.NotMoreThanEnoughDamage                                   ;&gt;Failsafe, if DamageCount is greater than DamageAmountToDie, remaining HP cannot go negative, so...
			?.MoreThanEnough
				LDA #$00                                                ;&gt;...Set it to 0.
			?.NotMoreThanEnoughDamage
				STA !Freeram_SpriteHP_CurrentHPLow,x                    ;&gt;otherwise just write the non-negative difference as HP.
			if !Setting_SpriteHP_TwoByte != 0
				LDA #$00                                                ;\Rid high bytes.
				STA !Freeram_SpriteHP_CurrentHPHi,x                     ;|(So far, there is never a sprite that stores a 16-bit damage counter)
				STA !Freeram_SpriteHP_MaxHPHi,x                         ;/
			endif
	endmacro
</pre></div>
	For example, Chargin' Chucks have their damage counter stored at sprite table <kbd>$1528</kbd>. This means to call the macro with the <kbd>DamageCountSpriteTableRAM</kbd> set to <kbd>!1528</kbd> (address changed to a define for SA-1 hybrid support).
	With the patch installed, the sprite dies if the damage counter reaches 15 or more. So the <kbd>DamageAmountToDie</kbd> should be 15. With this, the macro should be called like this: <span class="NoLineBreak">%ConvertDamageAmountToHP(!1528, 15)</span>.
	Now note, this is assuming you've patched <kbd>HPSystemForSMWSprites.asm</kbd> into your game. Reason for modifying bosses and enemies that take damage from fireballs and stomps is because of how janky it is.<br><br>
	
	<span id="HitCountJank">Take for example, Chargin Chucks. Logically, it takes 5 fireballs to kill or 3 stomps to kill, you'd think the fireballs would deal less damage than a stomp attack (because more hits to kill means it deals
	less damage on the same amount of HP). But it doesn't work like that, internally, SMW will always increases the damage counter by 1 reguardless if the attack is a fireball or a stomp
	attack, and to tell if it reaches the amount of damage needed to kill the sprite, that amount itself depends on the last hit being a fireball (5 or more) or stomp attack (3 or more).
	Therefore techinically Chucks will take the same amount of damage of either the fireball or stomp, and the death condition is if after the last hit, the damage counter is 5 or more from a
	fireball, or 3 or more from the stomp attack.</span><br><br>
	
	The same also applies to Ludwig, Morton, and Roy. 12 fireballs or 3 stomps.<br><br>
	
	As a speedrunner trick, you can quickly kill Chucks, Ludwig, Morton, and Roy by shooting 2 fireballs (which ignores the temporary invulnerability state after taking damage), then jumping on them.<br><br>
	
	The patch modifies this to work as an actual damage system. Damages from fireballs and stomps deal different amounts, and there is only one value (reguardless of attack type) that if the damage counter reaches or exceeds it, kills the sprite.
	By default, Chucks needed 15 or more points of damage to defeat, fireballs deal 3 damage and stomps deal 5. And for Ludwig, Morton, and Roy, they needed 12 points to defeat, with fireballs dealing 1 damage, and Stomp attacks dealing 4.
	All of these preserves the amount of same-attack-types hits to be the same as vanilla.
	</p>
	<h4><a href="#ToC_MakeSpritesDisplayHP_GetHPValue_GetStraightFromHPSprTbl" id="JMPTo_MakeSpritesDisplayHP_GetHPValue_GetStraightFromHPSprTbl">^</a>...from its own sprite table as HP</h4>
	<p>
		This assumes that the custom sprite you have stores the health amount (a number starting at some nonzero value, and decreases when taking damage) rather than a damage/hit counter. This, is in fact, even easier than having to invert
		the damage counter. All you have to do is simply load its source HP data, and store it directly into the HP data of this ASM resource:
<div class="CodeBlock" style="height: 200px;"><pre>
	macro TransferHealthToHPData(HealthSpriteTableRAM, MaxHealth)
		LDA &lt;HealthSpriteTableRAM&gt;,x                                    ;\Transfer its own HP data to this ASM resource's HP data
		STA !Freeram_SpriteHP_CurrentHPLow,x                            ;/
		LDA.b #&lt;MaxHealth&gt;                                              ;&gt;Warning, make sure the define being set to a value does not have the hash symbol (must be !HitPoints = $03, not !HitPoints = #$03), else asar will complain
		STA !Freeram_SpriteHP_MaxHPLow,x
		if !Setting_SpriteHP_TwoByte != 0
			LDA #$00                                                ;\Rid high bytes.
			STA !Freeram_SpriteHP_CurrentHPHi,x                     ;|(So far, there is never a sprite that stores a 16-bit health amount)
			STA !Freeram_SpriteHP_MaxHPHi,x                         ;/
		endif
	endmacro</pre></div>
	One sprite that does this is the <a href="https://www.smwcentral.net/?p=section&a=details&id=3723">Spiny Boss</a> from SMWCP1. It stores its HP data in RAM <kbd>$1528</kbd> (defined as <kbd>!sprite_health</kbd>). In that case, you simply have to
	do this: <span class="NoLineBreak">%TransferHealthToHPData(!sprite_health, !MaxHP)</span> under its &ldquo;<kbd>SpriteCode</kbd>&rdquo; before any code.
	</p>
	<h3><a href="#ToC_MakeSpritesDisplayHP_TakingDamage" id="JMPTo_MakeSpritesDisplayHP_TakingDamage">^</a>Damage handler</h3>
	<p>Like I said before, the sprite having HP/Damage system must have something that would track the amount health or damage when a hit occurs, else it would take one hit to kill or have infinite HP. Thankfully most sprites have comments and defines
	in their ASM codes (CTRL+F to see how the defines are being used and you get a clue on what RAM is its health/damage) that tell you what the codes do. However, this isn't just changing the HP amounts when the sprite takes damage or heals, you also to do in addition:
	<ul>
		<li>If you have animation enabled (<kbd>!Setting_SpriteHP_BarAnimation</kbd> set to <kbd>1</kbd>), you need to set some values for that.</li>
		<li>Ensure that the health meter switches to that damaged enemy when hit.</li>
	</ul>
	Thankfully, all that logic is handled automatically in a subroutine defined as <kbd>!SharedSub_SpriteHPDamage</kbd>, with the inputs stored in <kbd>$00</kbd> (2 bytes if <kbd>!Setting_SpriteHP_TwoByte == 1</kbd>). Feel free to check out the subroutines as you wish.</p>
	
	<p>If you want to know how it works, just open the provided custom sprite's asm file or view the provided patch and seeing the SMW disassembly. Please note that, because patches, uberasm tool, and pixi have their own isolated subroutines system,
	and I don't want to have duplicate subroutines, the patch version on handling the bar animation is very different, it does not calculate via RAM on how many pieces are in the bar to determine, rather a pre-calculated number of pieces in the bar.</p>
	
	<p>If you're dealing with an incremental damage counter-type HP for bosses and wanted a damage animation, you would do the same thing, just make sure the how much it increases are stored in <kbd>$00</kbd> (<kbd>$00~$01</kbd> if <kbd>!Setting_SpriteHP_TwoByte == 1</kbd>), for example,
	the <a href="https://www.smwcentral.net/?p=section&a=details&id=13144">Giant Masked Koopa boss</a>:
<div class="CodeBlock" style="height: 70px;"><pre>
    INC !1534,x                 ; increment sprite hit counter (this counts the damage up by 1)
    LDA !1534,x                 ;\ If it has incremented to the "max", do death animation.
    CMP.b #!HitPoints           ; |
    BEQ SpriteDead              ;/
</pre></div><br>
	Should be changed to:<br>
<div class="CodeBlock" style="height: 230px;"><pre>
    INC !1534,x                 ; increment sprite hit counter (this counts the damage up by 1)
    if !Setting_SpriteHP_TwoByte
        REP #$20
        LDA #$0001
        STA $00
        SEP #$20
    else
        LDA #$01
        STA $00
    endif
    JSL !SharedSub_SpriteHPDamage             ;Reflect the damage over to the sprite HP data (yes, the HP data is already synced via macro call of "ConvertDamageAmountToHP", however this may only happen before this code, which may cause 1-frame off-sync)
    LDA !1534,x                               ;\ If it has incremented to the "max", do death animation.
    CMP.b #!HitPoints                         ; |
    BEQ SpriteDead                            ;/
</pre></div><br>
	The same goes with if it have a health counter rather than a damage counter. For example, the Spiny Boss's damage code (yeah, some of the comments are incorrect, such as &ldquo;Increase&rdquo; when it supposed to say &ldquo;Decrease&rdquo;.):<br>
<div class="CodeBlock" style="height: 60px"><pre>    DEC !sprite_health,x        ; Increase hit counter and...
    LDA !sprite_health,x        ; \ Check if the sprite has been hit 3 times
    BNE .justHit</pre></div><br>
	To be changed to:<br>
<div class="CodeBlock" style="height: 200px"><pre>    DEC !sprite_health,x        ; Increase hit counter and...
    if !Setting_SpriteHP_TwoByte
        REP #$20
        LDA #$0001
        STA $00
        SEP #$20
    else
        LDA #$01
        STA $00
    endif
    JSL !SharedSub_SpriteHPDamage
    LDA !sprite_health,x        ; \ Check if the sprite has been hit 3 times
    BNE .justHit</pre></div><br>
    
	Be careful that if scratch RAM <kbd>$00~$01</kbd> was used before and after here and needs to be retained, you need to preserve it before you write to <kbd>$00~$01</kbd> and restore it after <kbd>JSL !SharedSub_SpriteHPDamage</kbd>, or place it in an area where <kbd>$00~$01</kbd> is not used at all. For preserving values
	it shoud look like this:
<div class="CodeBlock" style="height: 390px"><pre>    ;[...]
    if !Setting_SpriteHP_TwoByte
        REP #$20
        LDA $00                 ;\Push RAM $00~$01 into stack
        PHA                     ;/
        LDA #$0001
        STA $00
        SEP #$20
    else
        LDA $00                 ;\Push RAM $00 into stack
        PHA                     ;/
        LDA #$01
        STA $00
    endif
    JSL !SharedSub_SpriteHPDamage
    if !Setting_SpriteHP_TwoByte
        REP #$20
        PLA                     ;\Restore $00~$01 from the stack
        STA $00                 ;/
        SEP #$20
    else
        PLA                     ;\Restore $00 from the stack
        STA $00                 ;/
    endif
    ;[...]</pre></div><br>
	Now, if the sprite can take <b>multiple points of damage</b> instead of <kbd>1</kbd> point (and often have multiple ways to deal damage than just stomp), such as the <a href="https://www.smwcentral.net/?p=section&a=details&id=30909">Wreckin' Chuck</a> by Sonikku,
	then you should also have those damages reflected into RAM <kbd>$00</kbd>. Here is the code that handles increasing the damage count:
<div class="CodeBlock" style="height: 190px;"><pre>	;[...]
.DealDamage
;; play sfx
	LDA #$28
	STA $1DFC|!addr
;; get amount of damage in Y
	TYA
	CLC
	ADC !1528,x
	CMP #!Damage_MaxHP
	BCC +
	;[...]
</pre></div><br>

Change that to this:
<div class="CodeBlock" style="height: 260px;"><pre>	;[...]
.DealDamage
;; play sfx
	LDA #$28
	STA $1DFC|!addr
;; get amount of damage in Y
	STY $00                              ;&gt;Store damage from the Y register to $00
	if !Setting_SpriteHP_TwoByte
		STZ $01
	endif
	JSL !SharedSub_SpriteHPDamage
	TYA
	CLC
	ADC !1528,x
	CMP #!Damage_MaxHP
	BCC +
	;[...]
</pre></div><br>
	If there are multiple instances of increasing/decreasing the RAM (espically if it doesn't utilizes a subroutine to merge them into one), then every one of them should be changed to include setting RAM <kbd>$00</kbd> (<kbd>$00~$01</kbd> if <kbd>!Setting_SpriteHP_TwoByte</kbd> is set to <kbd>1</kbd>)
	and then calling <kbd>JSL !SharedSub_SpriteHPDamage</kbd> so all damage types will perform the animation (if you enabled it) and other effects (such as switching the health meter to the sprite you dealt damage to).
	</p>
	<hr>
	<h2><a href="#ToC_Notes" id="JMPTo_Notes">^</a>Notes</h2>
	<ul>
		<li>Any sprite (most likely custom sprites) with 6th tweaker byte's (RAM <a href="https://smwc.me/m/smw/ram/7E190F"><kbd>$190F</kbd></a>) bit 3 (<kbd>Takes 5 fireballs to kill</kbd>) being set will also be affected by this patch. In the original game, this feature was only used by Chargin' Chucks and
		all its variants. Instead of counting RAM <a href="https://smwc.me/m/smw/ram/7E1528"><kbd>$1528</kbd></a> up by 1 and killing the sprite when reaches 5 or more, it counts up by a value defined as <kbd>!Setting_SpriteHP_FireballDamageAmount</kbd>,
		and dies if this number reaches or exceeds a value defined as <kbd>!Setting_SpriteHP_VanillaSprite_Chucks_HPAmount</kbd> (these are found in <kbd>EnemyHPMeterDefines.asm</kbd>). The code checking if enough damage have been made by the fireballs is
		processed by the fireballs' code (at <kbd>$02A0FC</kbd>) rather than the sprite's code.</li>
		<li>Ludwig, Morton, and Roy, however, their sprite code processes the fireball damage manually, and does not utilizes the 5 fireballs tweaker bit.</li>
	</ul>
	<hr>
	<h2><a href="#ToC_Troubleshooting" id="JMPTo_Troubleshooting">^</a>Troubleshooting</h2>
	<ul>
		<li>
			Q: &ldquo;When the HP meter appears, and despite the setting <kbd>!Setting_SpriteHP_DisplayNumerical</kbd> set to <kbd>1</kbd> or <kbd>2</kbd>, the numbers won't appear anyway.&rdquo;<br><br>
			A: The sprite have too much HP digits, either have lower HP values or set <kbd>!Setting_SpriteHP_MaxDigits</kbd> to a higher value. Not showing the text is a failsafe if the string gets too long. That failsafe is intended to avoid writing too many symbols
			onto the status bar that some tiles that supposed to disappear failed to do so (when the string gets shorter). You can turn it off (may come with such a risk) by setting <kbd>!Setting_SpriteHP_ExcessDigitProt</kbd> to <kbd>0</kbd>.
		</li>
		<li>
			Q: &ldquo;When I damage an enemy that uses the HP system, it's HP shown won't go down!&rdquo;<br><br>
			A: There are possible cases that have occurred:
			<ul>
				<li>Numbers not showing (either because you have them disabled or too many symbols in the text display of the numbers), and it's HP is set above its maximum.</li>
				<li>The amount of damage it receives was set to 0 damage, causing no changes on its HP value.</li>
				<li>You forgot to modify the sprite's code to write its own HP data into this ASM resource' HP data to display properly.</li>
				<li>With the numbers not showing, if you have more max HP than the number of pieces the bar has, small damages can result in the bar visibly not updating. This is because a range of current HP values get approximated (rounded) to the
				same amount of fill in the bar.</li>
			</ul>
		
		</li>
		<li>
			Q: &ldquo;My game crashed! What happened?&rdquo;<br><br>
			A: Possible causes:
			<ul>
				<li>RAM conflicts. The RAM usage on this package alone are the sprite HP data, a byte used for Wendy/Lemmy to tell if the intro-fill have been played (by default, it is the address of the last block of the level map16 data; which you are
				unlikely to use in a 1-screen wide boss room), graphical bar input and outputs, and the character tile table for displaying aligned text for leading-zero suppression. While &ldquo;<kbd>!Scratchram_&lt;ResourceName&gt;...</kbd>&rdquo; can be reused as another scratch RAM (as
				long as after the code finish using it you can re-use it for something else), the same can't be said if they are named &ldquo;<kbd>!Freeram_&lt;ResourceName&gt;...</kbd>. Make sure you pay attention on every installed ASM resource
				on what RAMs are being used. If you have trouble knowing if a RAM conflicts, use the Address Tracker as mentioned in the recommended at the top of this readme.</li>
				<li>Hijack conflicts. This should only be possible if you patch <kbd>HPSystemForSMWSprites.asm</kbd> along with 3rd party patches that also modifies SMW's sprites with overlapping hijacks with those said patches (such as
				<a href="https://www.smwcentral.net/?p=section&a=details&id=20847">&ldquo;FireBall HP&rdquo;</a> patch by Bio).</li>
				<li>
					Incorrect use of Shared Subroutines:
					<ul>
						<li>
							Using an Incorrect address for Shared Subroutines JML list. Make sure you place it at an actual freespace and not address occupied by the original game, other patches, including by other tools and Lunar Magic. Best way to fix is to revert your game to a previous
							state before patching Shared Subroutines, correct the address for the JML list, re-patch, and update every copy of the Shared Subroutine defines for all ASM resources using the Shared Subroutines and re-insert them.
						</li>
						<li>You've relocated the JML list but not updated the defines that references the JML list in other ASM stuff, causing the game's code to jump to an old outdated area that is invalid.</li>
					</ul>
				
				</li>
				<li>Faulty code that you have found that I didn't catch (most likely if you haven't installed any other ASM resource). PM me or the moderators on fixing a newly discovered bug. If I'm inactive, feel free to update it.</li>
			</ul>
		
		</li>
	</ul>
</div>
<script>
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
</script>